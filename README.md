# JS 이론 정리
## 1. 변수
```javascript
console.log(score); //undefined
var score;
```
JS는 위에서 부터 한줄 식 실행하는 **인터프리터 언어**이기 때문에 _Reference Error_ 를 예측할 수 있다. 그러나 Console 창에서는 _undefined_ 결과를 출력한다.

두 줄의 코드가 javascript 내에서 어떻게 동작을 할까?

JS 엔진은 한줄씩 코드를 실행하기 전. 즉, 런타임 이전  **소스코드 평가 과정**이 존재한다.
> 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아 실행

즉, 
```javascript
console.log(score);
var score;              // 소스코드 평가에서 변수 선언문인 var score; 를 먼저 실행
```
var score; 줄을 실행할 때, 알아둬야하는 점이 있다. 변수선언에는 2가지 과정이 있다.
> 선언 단계 : 변수 이름을 등록해서 JS 엔진의 변수의 존재를 알린다.
> 초기화 단계 : 값을 저장하기 위해 메모리 공간을 확보하고, 암묵적으로 undefined를 할당한다.

여기서 **var** 키워드는 선언단계와 초기화 단계가 동시에 이루어진다.

정리하자면, 
1. 런타임 이전 **소스코드 평가과정**에 의해 변수 선언문인 var score; 가 먼저 실행이 된다.
2. **var** 키워드로 인해 변수 선언의 2가지 과정(선언단계, 초기화단계)이 동시에 이루어진다.
3. **소스코드 평가과정**이 끝나면 **런타임**에서 console.log(score); 로 인해 *score라는 변수이자 식별자가 가리키는 메모리 주소의 값인 undefined가 출력된다.*

이 과정에 의해 마치 밑에 변수가 맨 위에 선언된 것처럼 동작하는데, 이를 😁*호이스팅(hoisting)* 이라고 한다.

### 응용
```javascript
console.log(score);
var test = 1234;
```
그렇다면 위의 결과는 어떨까?
> 정답은 undefined 이다.
다시 한번 언급하자면 1. *JS 엔진은 **소스코드 평가과정**에 의해 선언문 부터 찾아낸다.* 2. *var* 키워드는 선언과 초기화를 동시에 진행한다.
그러나 값의 할당(1234)는 *소스코드 평가과정*에서 실행되지 않고, 런타임 과정에서 실행된다.
값이 할당되기 전 console.log(score); 가 실행되므로, **"undefined"** 이다. 

### 또 알아야 할것
```javascript
var score = 80;
score = 90;
```
위 코드는 다음과 같이 실행된다
> 1. 소스코드 평가과정에서 score에 undefined가 초기화 된다.
> 2. 런타임에서 score에 80이 할당된다.
> 3. score에 90이 할당된다.


위 코드가 실행되는 과정을 설명하였는데, 이것은 정확히 말하자면 틀렸다. 정확히는


> 1. 소스코드 평가과정에서 score에 undefined가 초기화 된다.
> 2. 런타임에서 80이 할당된 메모리 주소를 score 식별자가 가리킨다. 
> 3. 90이 할당된 메모리 주소를 score 식별자가 가리킨다.

🙄그렇다면 undefined와 80이 할당되어 있는 공간은? >>>>> 가비지 콜렉터에 메모리에서 자동해제 된다.
